package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/zoobzio/tracez"
)

// Middleware for tracing HTTP requests.
func TracingMiddleware(tracer *tracez.Tracer) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Start root span for request.
			ctx, span := tracer.StartSpan(r.Context(), tracez.HTTPRequestKey)
			span.SetTag("http.method", r.Method)
			span.SetTag("http.path", r.URL.Path)
			span.SetTag("http.remote_addr", r.RemoteAddr)
			defer span.Finish()

			// Wrap response writer to capture status code.
			wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}

			// Pass traced context to next handler.
			next.ServeHTTP(wrapped, r.WithContext(ctx))

			// Record response details.
			span.SetTag("http.status_code", fmt.Sprintf("%d", wrapped.statusCode))
		})
	}
}

// AuthMiddleware checks authentication.
func AuthMiddleware(tracer *tracez.Tracer) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if tracer == nil {
				next.ServeHTTP(w, r)
				return
			}

			// Create auth span.
			ctx, span := tracer.StartSpan(r.Context(), "auth.check")
			defer span.Finish()

			// Simulate auth check.
			token := r.Header.Get("Authorization")
			if token == "" {
				span.SetTag("auth.result", "missing_token")
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			// Simulate token validation.
			time.Sleep(5 * time.Millisecond)
			span.SetTag("auth.result", "valid")
			span.SetTag("auth.user_id", "user-123")

			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// LoggingMiddleware logs request details.
func LoggingMiddleware(tracer *tracez.Tracer) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if tracer == nil {
				next.ServeHTTP(w, r)
				return
			}

			ctx, span := tracer.StartSpan(r.Context(), "logging.request")
			span.SetTag("log.level", "info")
			defer span.Finish()

			// Log request.
			fmt.Printf("[%s] %s %s\n", time.Now().Format("15:04:05"), r.Method, r.URL.Path)

			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// PaymentMiddleware demonstrates circuit breaker based on span analysis.
func PaymentMiddleware(tracer *tracez.Tracer) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if tracer == nil {
				next.ServeHTTP(w, r)
				return
			}

			// Check for retry storm indicators in parent span BEFORE creating our span
			totalRetries := 0
			if parentSpan := tracez.GetSpan(r.Context()); parentSpan != nil {
				for key, value := range parentSpan.Tags {
					if strings.HasPrefix(key, "retry.") && strings.HasSuffix(key, ".count") {
						if count, err := strconv.Atoi(value); err == nil {
							totalRetries += count
						}
					}
				}
			}

			ctx, span := tracer.StartSpan(r.Context(), "payment.middleware")
			defer span.Finish()

			span.SetTag("payment.total_retries", fmt.Sprintf("%d", totalRetries))

			// Circuit breaker logic
			if totalRetries > 5 {
				span.SetTag("circuit.breaker", "open")
				span.SetTag("circuit.reason", "retry_storm_protection")
				http.Error(w, "Payment circuit breaker open", http.StatusServiceUnavailable)
				return
			}

			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// RetryMiddleware coordinates retries across service layers.
func RetryMiddleware(tracer *tracez.Tracer, layer string, maxRetries int) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if tracer == nil {
				next.ServeHTTP(w, r)
				return
			}

			ctx, span := tracer.StartSpan(r.Context(), "retry."+layer)
			defer span.Finish()

			// Simulate retry attempts for demonstration
			retryCount := 0
			if strings.Contains(r.URL.Path, "payment") && layer == "api" {
				// Simulate API layer retries
				retryCount = 3
			} else if strings.Contains(r.URL.Path, "payment") && layer == "db" {
				// Simulate database layer retries
				retryCount = 2
			}

			span.SetTag(fmt.Sprintf("retry.%s.count", layer), fmt.Sprintf("%d", retryCount))
			span.SetTag("retry.max_allowed", fmt.Sprintf("%d", maxRetries))

			// Simulate retry delays
			if retryCount > 0 {
				for i := 1; i <= retryCount; i++ {
					_, retrySpan := tracer.StartSpan(ctx, fmt.Sprintf("retry.%s.attempt", layer))
					retrySpan.SetTag("retry.attempt", fmt.Sprintf("%d", i))
					retrySpan.SetTag("retry.layer", layer)

					// Exponential backoff simulation
					backoffMs := 100 * (1 << uint(i-1))
					time.Sleep(time.Duration(backoffMs) * time.Millisecond)
					retrySpan.SetTag("retry.backoff_ms", fmt.Sprintf("%d", backoffMs))

					retrySpan.Finish()
				}
			}

			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// Application handlers.
func handleUsers(tracer *tracez.Tracer) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if tracer == nil {
			if err := json.NewEncoder(w).Encode(map[string]interface{}{"users": []string{"alice", "bob"}}); err != nil {
				http.Error(w, "Failed to encode response", http.StatusInternalServerError)
			}
			return
		}

		ctx, span := tracer.StartSpan(r.Context(), "handler.users")
		defer span.Finish()

		// Simulate database query.
		_, dbSpan := tracer.StartSpan(ctx, tracez.DBQueryKey)
		dbSpan.SetTag("db.table", "users")
		dbSpan.SetTag("db.operation", "SELECT")
		time.Sleep(10 * time.Millisecond)
		dbSpan.Finish()

		// Simulate cache check.
		_, cacheSpan := tracer.StartSpan(ctx, tracez.CacheGetKey)
		cacheSpan.SetTag("cache.key", "users:all")
		cacheSpan.SetTag("cache.hit", "false")
		time.Sleep(2 * time.Millisecond)
		cacheSpan.Finish()

		// Return response.
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(map[string]interface{}{
			"users": []string{"alice", "bob", "charlie"},
			"count": 3,
		}); err != nil {
			http.Error(w, "Failed to encode response", http.StatusInternalServerError)
		}
	}
}

func handleProfile(tracer *tracez.Tracer) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if tracer == nil {
			http.Error(w, "Profile not found", http.StatusNotFound)
			return
		}

		ctx, span := tracer.StartSpan(r.Context(), "handler.profile")
		defer span.Finish()

		// Parse user ID.
		userID := r.URL.Query().Get("id")
		if userID == "" {
			span.SetTag("error", "missing_user_id")
			http.Error(w, "User ID required", http.StatusBadRequest)
			return
		}
		span.SetTag("user.id", userID)

		// Simulate external API call.
		_, apiSpan := tracer.StartSpan(ctx, tracez.ExternalAPIKey)
		apiSpan.SetTag("api.service", "profile-service")
		apiSpan.SetTag("api.endpoint", "/profile/"+userID)
		time.Sleep(15 * time.Millisecond)
		apiSpan.Finish()

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(map[string]interface{}{
			"id":   userID,
			"name": "Test User",
		}); err != nil {
			http.Error(w, "Failed to encode response", http.StatusInternalServerError)
		}
	}
}

func handlePayment(tracer *tracez.Tracer) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if tracer == nil {
			http.Error(w, "Payment processing unavailable", http.StatusServiceUnavailable)
			return
		}

		ctx, span := tracer.StartSpan(r.Context(), "handler.payment")
		defer span.Finish()

		// Parse payment details
		paymentID := r.URL.Query().Get("id")
		if paymentID == "" {
			span.SetTag("error", "missing_payment_id")
			http.Error(w, "Payment ID required", http.StatusBadRequest)
			return
		}

		amount := r.URL.Query().Get("amount")
		if amount == "" {
			amount = "89.99"
		}

		span.SetTag("payment.id", paymentID)
		span.SetTag("payment.amount", amount)
		span.SetTag("payment.method", "visa")

		// Simulate payment validation
		_, validationSpan := tracer.StartSpan(ctx, "payment.validate")
		validationSpan.SetTag("validation.result", "success")
		time.Sleep(8 * time.Millisecond)
		validationSpan.Finish()

		// Simulate payment processing with external API calls
		_, processSpan := tracer.StartSpan(ctx, "payment.process")
		processSpan.SetTag("processor", "stripe")
		defer processSpan.Finish()

		// Simulate external API calls (these would trigger retries)
		for i := 1; i <= 3; i++ {
			_, apiSpan := tracer.StartSpan(ctx, tracez.ExternalAPIKey)
			apiSpan.SetTag("api.service", "stripe")
			apiSpan.SetTag("api.endpoint", "/charges")
			apiSpan.SetTag("api.attempt", fmt.Sprintf("%d", i))

			// Simulate API latency and 429 responses
			time.Sleep(200 * time.Millisecond)
			if i < 3 {
				apiSpan.SetTag("http.status_code", "429")
				apiSpan.SetTag("api.error", "rate_limited")
			} else {
				apiSpan.SetTag("http.status_code", "200")
				apiSpan.SetTag("api.success", "true")
			}
			apiSpan.Finish()
		}

		// Simulate database operations (these would also trigger retries)
		_, dbSpan := tracer.StartSpan(ctx, tracez.DBQueryKey)
		dbSpan.SetTag("db.table", "payments")
		dbSpan.SetTag("db.operation", "INSERT")
		dbSpan.SetTag("db.query", "INSERT INTO payments (id, amount, status) VALUES (?, ?, ?)")
		time.Sleep(25 * time.Millisecond)
		dbSpan.Finish()

		// Return success response
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(map[string]interface{}{
			"payment_id": paymentID,
			"amount":     amount,
			"status":     "success",
			"timestamp":  time.Now().Unix(),
		}); err != nil {
			http.Error(w, "Failed to encode response", http.StatusInternalServerError)
		}
	}
}

// responseWriter captures status code.
type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

func main() {
	// Setup tracer.
	tracer := tracez.New("http-service")
	defer tracer.Close()

	collector := tracez.NewCollector("http-traces", 1000)
	tracer.AddCollector("collector", collector)

	// Start trace exporter.
	go func() {
		ticker := time.NewTicker(2 * time.Second)
		defer ticker.Stop()

		for range ticker.C {
			spans := collector.Export()
			if len(spans) > 0 {
				fmt.Printf("\n=== Trace Report (%d spans) ===\n", len(spans))

				// Group spans by trace ID.
				traces := make(map[string][]tracez.Span)
				for i := range spans {
					span := &spans[i]
					traces[span.TraceID] = append(traces[span.TraceID], *span)
				}

				// Display each trace.
				for traceID, traceSpans := range traces {
					fmt.Printf("\nTrace: %s\n", traceID[:8])
					for i := range traceSpans {
						span := &traceSpans[i]
						indent := ""
						if span.ParentID != "" {
							indent = "  "
							if countParents(traceSpans, *span) > 1 {
								indent = "    "
							}
						}
						fmt.Printf("%s[%s] %v", indent, span.Name, span.Duration)
						if len(span.Tags) > 0 {
							fmt.Printf(" tags=%v", span.Tags)
						}
						fmt.Println()
					}
				}
			}
		}
	}()

	// Setup HTTP server with middleware chain.
	mux := http.NewServeMux()
	mux.HandleFunc("/users", handleUsers(tracer))
	mux.HandleFunc("/profile", handleProfile(tracer))
	mux.HandleFunc("/payment", handlePayment(tracer))

	// Chain middleware: Tracing -> Auth -> Payment -> Retries -> Logging -> Handler.
	// This demonstrates the retry storm pattern with multiple retry layers.
	handler := TracingMiddleware(tracer)(
		AuthMiddleware(tracer)(
			PaymentMiddleware(tracer)(
				RetryMiddleware(tracer, "api", 3)(
					RetryMiddleware(tracer, "db", 2)(
						LoggingMiddleware(tracer)(mux),
					),
				),
			),
		),
	)

	fmt.Println("Server starting on :8080")
	fmt.Println("Try:")
	fmt.Println("  curl -H 'Authorization: token123' http://localhost:8080/users")
	fmt.Println("  curl -H 'Authorization: token123' http://localhost:8080/profile?id=456")
	fmt.Println("  curl -H 'Authorization: token123' http://localhost:8080/payment?id=pay-123&amount=89.99")
	fmt.Println("  curl http://localhost:8080/users (will fail auth)")
	fmt.Println("")
	fmt.Println("Payment endpoint demonstrates retry storm pattern:")
	fmt.Println("- API layer retries: 3 attempts")
	fmt.Println("- DB layer retries: 2 attempts") 
	fmt.Println("- Circuit breaker activates after 5 total retries")
	fmt.Println("- Watch span hierarchies show retry amplification")

	server := &http.Server{
		Addr:         ":8080",
		Handler:      handler,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}
	if err := server.ListenAndServe(); err != nil {
		fmt.Printf("Server error: %v\n", err)
	}
}

func countParents(spans []tracez.Span, target tracez.Span) int {
	count := 0
	current := target
	for current.ParentID != "" {
		for i := range spans {
			s := &spans[i]
			if s.SpanID == current.ParentID {
				count++
				current = *s
				break
			}
		}
		if count > 10 { // Prevent infinite loop.
			break
		}
	}
	return count
}
